# Event API: Authentication

* ID: ADR035
* Status: :accepted:
* Deciders: @cgr @ths
* Date: 2024-02-13
* Version: 1.0
* Category: Security

## Context and Problem Statement

With the implementation of the Event Management API in the prototype, the question of authentication gained new weight:
While all other APIs require a customized implementation that can do the authentication in a bespoke manner, event callbacks are by nature used rather generic.
We have to decide how to handle authentication here, potentially improving the API or documenting another chosen approach.

## Decision Drivers

* Must allow authentication of event transmission
* May be applied to other APIs

## Considered Options

* API-Tokens as URL-Parameters
* Allow definition of additional headers on callback registration
* Allow explicit definition of authentication on callback registration
* Configuration as part of the implementation

## Decision Outcome

Chosen option: "Configuration as part of the implementation", because it is the most flexible and secure approach.
While it is not self-describing, we consider a separate configuration a security improvement.

## Compliance

* A description of the chosen approach is added to the ICD
* A reference is added to the TOD entry of the callback registration

## Pros and Cons of the Options

### API-Tokens as URL-Parameters

API-Tokens are randomized strings that are generated by (and therefore bound to) individuals or organizations, i.e., providers.
They may have a limited lifetime (usually days or months), but are often manually invalidated.
Since they are simply appended to the callback URL, this approach would require no changes in the API.

* Good, because simple interface
* Bad, because tendency for long token lifetimes
* Bad, because hard to combine with other authentication methods
* Bad, because the registering side must track the lifetime of the token and provide an updated callback URL in time.

### Allow Definition of additional Headers on Callback Registration

HTTP defines an "Authorization" header, which could be used in different ways.
In "Basic" mode it transports classic credentials, but it can also be used for [API-Tokens](#api-tokens-as-get-parameters).
We could extend the Event Management API to allow the definition of such headers together with the callback URL.

* Good, because simple interface
* Bad, because tendency for long token lifetimes
* Bad, because not compatible with OAuth2
* Bad, because the registering side must track the lifetime of the token and provide an updated header configuration in time.

### Allow explicit Definition of Authentication on Callback Registration

To allow OAuth2 as an authentication method, we would have to add more attributes to the registration endpoint than just fixed headers.
We could use the definition in the [Open API standard](https://swagger.io/docs/specification/authentication/) as inspiration.
In addition, we'd have to store the actual credentials with it.

* Good, because self-describing
* Good, because supports all authentication methods
* Bad, because interface complexity
* Bad, because transport/storage of credentials potentially insecure

### Configuration as Part of the Implementation

As of writing this decision record, authentication is defined to be implementation-specific.
This results from the different security requirements of every system that can not be easily unified.

Keeping this concept, we could suggest an implementation specific, host-based configuration of authentication.
This would impose a list of allowed hosts for callbacks, which would improve the security in itself.
Additionally, the list would be augmented with a specific authentication method for each one, including OAuth2 or any other method discussed in this decision.
The implementation can offer this as a self-service to the providers or limit it to the system operators (e.g. for security reasons or complexity concerns).
The Event API would be kept as-is, because the workflow is expected to be done beforehand.

* Good, because adjustable to every implementation
* Good, because supports all authentication methods
* Good, because improved security
* Bad, because not self-describing

## Implications for the Scope

The interface is developed with state-of-the-art designs and is based on a common industry standard.
The interface is to be understood as an enabler for security aspects, not enforcing such for a PSS connected to it.
