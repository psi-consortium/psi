# Introduction of a common model

* ID: ADR037
* Status: :proposed:
* Deciders: @ths, @ncz
* Consulted: @cgr
* Date: 2024-07-10
* Version: 1.0
* Category: Architecture

Technical Story: Define a common PSID-Model

## Context and Problem Statement

How can *model conflicts* be resolved when generating Java code based on 1+n PSID swagger definitions?

### Detail

#### Current State

Problems with TMF definitions and/or Patty adjustments:

1. Many REST endpoints are of no interest for PSI.
   * Removed by JSON transformation / patty.
2. Entities might be completely or partially of no interest for PSI.
   * Removed by JSON transformation / patty.
3. Entities required for PSI might be missing completely or partially.
   * Add by JSON transformation / patty.
4. Entities may differ between different TMF APIs.
   * Adjustments by JSON transformation / patty.
5. Processing of updated Version of TMF APIs could work out of the box, but
   * still requires reviews and cleansing activities (see above)
   * Adjustments by JSON transformation / patty.
6. Classification of Entities (-> package structure) is missing in the TMF definitions.
   * Although TMF already did this grouping, see https://github.com/tmforum-rand/Open_Api_And_Data_Model-latest/blob/master/schemas
   * Manual adjustment of generated code.

The current state of the PSI "transform-and-build-workflow" for the PSID and mock-up artefacts contains the following main steps:

1. Choose TMF Specification
   * *Input:* as raw `TMF<API>.swagger.json` from TMF standard
   * Unchanged input files from TMF
2. Transform TMF to PSID
   * *Transformation:* via patty process
   * Transformation rules are defined by `TMF<API>swagger.transform.json`
   * Simple (search/replace) transformation process for one API input based on rules'
   * No extended functionality like condition handling/look ahead or behind
3. PSI-Definition
   * Agnostic usable swagger files (like `PSID<API>.swagger.json`) to develop implementations, tests or PoCs
4. Test PSID in mock-up
   * Java PoC-Implementation of PSID for test and verification
   * Model and interfaces are generated by https://openapi-generator.tech/

Above relates to [Swagger (JSON) File Patching for ICD Generation](./../Accepted/2022-09-01-json-patching-for-icd-generation_V1.0.md)

#### Problem Description

Multiple swagger definitions contain the same common components.
If you only want to use one definition, you won't notice any difference.
If you use at least two with common components, this can lead to problems.

In most cases, the swagger definitions for common components are 'nearly' the same.
'Nearly' means: the structure and naming of the properties maps fully, however additional fields may be different in detail.
There is a pipeline validation step established (`generateRestApiSchemas`) to validate this on a structural level based on the component name.
However, this validation succeeds if structural equality is given.
This is error-prone because common components need to be duplicated in multiple swaggers via copy & paste on any change by developer.
Even with a combination of at least two APIs, the generated code can differ for each generation, depending on which swagger definition was used first.

The following example focuses this behaviour via a difference on the `description` field:

First example of a swagger definition for a sample object (omitting the enclosing elements).

```json
"FooComponent": {
    "type": "object",
    "properties": {
        "bar": {
            "type": "string",
            "description": "The foo-bar description"
        }
    }
}
```

In opposite here a snippet of a second swagger file with a redundant definition, however with a difference in detail:

```json
"FooComponent": {
    "type": "object",
    "properties": {
        "bar": {
            "type": "string",
            "description": "Bar explanation in detail.",
        }
    }
}
```

Above definition is used for generation of a `FooComponent.java`.
If the code generation runs one after the other without deterministic sequence, it results in code which differ and/or lead to a conflicting code-base (*Step 4*).
Also, this generation only produces one `FooComponent.java` file at the end.

In extended cases, it is also possible to change a common component like above on structural level in one swagger file together with a missed change of the same component in another swagger file.
Here, classes like `FooComponent.java` and `FooComponent_1.java` will be generated by the OpenApi generator.
Also, the generated classes may differ by class properties.
Or, if the combined generation runs over multiple definitions, the classes will not be valid for *all used* OpenAPI definitions.

A decision needs to be made on how to ensure that the API definitions provided for release, have the same common components.
This means that instead of cascading changes to one component in a swagger file to others via manual copy and paste, an automatic method should be found to standardise these components to a common version across different definitions/files.

## Decision Drivers

* Simple solution, automation and integration via CI/CD is key.
  * Usage of already established tooling like patty, Gradle, groovy or OpenAPI Specification.
  * Use GitHub technology / deployment chain:\
    *"An implementation in a GitHub shall be targeted first. Local tooling is a fallback-solution. Wherever possible, local tooling should be avoided."*
* Final PSID swagger definitions should be self standing and decoupled.
* All resulting PSID files use the identical common syntax and structure of components.
* Further developments on the part of the underlying TM Forum APIs should be able to flow into the PSI interfaces without breakage and resistance.
* From a development perspective, there can only be one source of truth for a common 'master' model.\
  There is no longer a need for developers to cascade changes to shared data by copying and pasting between multiple definitions.

## Considered Options

* OpenAPI - Reference Object
* PSID swagger streamlining tool
* Harmonize all patty rules and improve build validation
* Locally Maintained Data Model
* :construction: / *TBD*

## Decision Outcome

*TBD*: Chosen option: "{option 1}", because {justification. e.g., only option, which meets k.o. criterion decision driver | which resolves force {force} | ... | comes out best (see below)}.

## Compliance

* *TBD*

### Positive Consequences

* conflicts/problems won't happen at implementation time - they arise before PSID release already at PSID development time

### Negative Consequences <!-- optional -->

* *TBD*

## Pros and Cons of the Options

### OpenAPI - Reference Object

Usage of references (https://learn.openapis.org/referencing/) to a separate common schema file.

* Good, because it uses a well known paradigm of Open API to reference common components.
  Familiar, flexible, and low-effort approach
* Good, because it needs no extra build integration, just replace all common components with the relevant reference.
* Bad, because if you want to implement only one API you have to manage more than one swagger file.
  The API definition is not fully described and self-contained/standing by one swagger file.
* Bad, no control nor validation/automation against duplicates or usage of conflicting common components.
* Bad, because multiple component schema files increases the complexity for someone who wants to implement only a small frame of PSID
  * more need to document the need the relationships leads to a higher learning curve

### PSID swagger streamlining tool

A Gradle task / groovy script could run after patty transformation to do the following approach:

1. after each patty run:
   * extract all used components (raw body or traverse the referring `$ref`/content) into separate schema-files
   * replace this with a unique ref to a unique schema file
   * if a schema file with this content (comparison of all content via hash) already exists, refer to it, else create new separate one
2. validation for conflicting duplicates
   * fail-fast inside the build on duplicate (conflicting) schema files, if no resolution is configured
3. rewrite all `$ref` (if conflict resolution is configured) to the configured component
4. add all referred components with configured content inside `components`

* Good, because can be established inside build, with deterministic output
* Good, because on validation failure the output (build folders) documents the conflicting problem as artefacts
* Good, configured resolution is under git control, each new conflict will be monitored
* Good, this approach will gracefully accept and *fix* any small typos inside the rules for the patty transformation
* Bad, because it is not directly obvious how the resulting PSID swaggers were created by (perhaps different rules) via Patty
* Bad, because of maintenance burden

### Harmonize all patty rules and improve build validation

1. Fix manual all conflicting definitions of the same component in different PSID's via patty.
2. Extend the build (`generateRestApiSchemas`) validation to validate *all* fields.

* Good, because it should fix all the stated problems and the current build workflow stays the same.
* Good, because this could happen again by mistake, but the extended, fully detailed validation will ensure quality in the future.
* Bad, because edit of one component leads to the effort to cascade the changes towards other places where the same component is used.

### Locally Maintained Data Model

Maintain required data models in single schema file per component:

1. All schemas definitions are stored in the form of a single file per component, similar to the way TM Forum is already doing it: https://github.com/tmforum-rand/Open_Api_And_Data_Model-latest/blob/master/schemas  
   (Could be generated from TMF API definition of downloaded from e.g. above URL)
2. Different TMF API definitions might provide differences on component schema level.
   These differences are aligned in the component schema files which will then serve as standardised schemas for the PSID definitions.
3. Version updates of the TMF API definition are transferred in the component schema files.
   This approach can be used even when introducing TMF API version updates.
4. New components required by PSI are added by introducing new schema files.
5. PSI driven adjustments of existing TMF schemas are carried out in the existing component schema files.
6. Finally, the generation of the PSID API definitions has to rely on the component schema files instead of the internal one.
   Additionally, the generation could start on a list of wanted REST endpoints, which is usually less than the amount of endpoints that usually have to be removed via the JSON transformation definitions.
   So, less work for the developer.
   But on the other hand, the generation process has to calculate the tree of referenced components on its own.
   Which in turn would result clean and full set of schemas for the resulting PSID API definition.

* Good, because the PSI Data Model, which will be located in the repository, is made clearly visible for everyone (not hidden in multiple PSI API definition files and corresponding JSON transformation files).
  Easy to compare with new or updated TM Forum API definitions (e.g. with the help of a new reporting tool).
* Good, because all PSI API definitions rely on the same data model and the generation itself will never run into problems again (no more problems due to different schema definitions in this step).
* Good, because integration of new or updated TMF API definitions means less work.
  (No maintenance of duplicated JSON transformations for multiple TM Forum API definitions.)
* Good, because the locally maintained data model could even reflect a classification (via a folder structure) that could be used for the ICD or Code generation (e.g. for Java Packages).
* Bad, because the initial state of the local data model must first be created. (Could be partially automated.)
* Bad, because the PSID API generation process has to be rewritten.

## Links

* An analysis and may be related problems as also how JSON Schemas should or could be processed is documented in
https://github.com/OAI/oascomply/blob/main/reports/processing-model-details.md
* https://learn.openapis.org/referencing/remove.html#convert-an-oad-to-a-single-document-form-without-any-references
* https://learn.openapis.org/referencing/resolve.html
