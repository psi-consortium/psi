package com.cgi.space.psi.common.model;

import java.net.URI;
import java.util.Objects;
import com.cgi.space.psi.common.model.Attachment;
import com.cgi.space.psi.common.model.CategoryRef;
import com.cgi.space.psi.common.model.Characteristic;
import com.cgi.space.psi.common.model.Document;
import com.cgi.space.psi.common.model.DocumentRefOrValue;
import com.cgi.space.psi.common.model.ExternalIdentifier;
import com.cgi.space.psi.common.model.RelatedEntity;
import com.cgi.space.psi.common.model.RelatedPartyRefOrPartyRoleRef;
import com.cgi.space.psi.common.model.TimePeriod;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.springframework.format.annotation.DateTimeFormat;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;


import java.util.*;
import javax.annotation.Generated;

/**
 * Document
 */
@com.fasterxml.jackson.annotation.JsonFilter(com.cgi.space.psi.common.config.DynamicJacksonFilterProvider.NAME)

@JsonIgnoreProperties(
  value = "@type", // ignore manually set @type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the @type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "@type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = Document.class, name = "Document")
})

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
public class Document implements DocumentRefOrValue {

  @JsonProperty("@type")
  private String atType;

  @JsonProperty("@baseType")
  private String atBaseType;

  @JsonProperty("@schemaLocation")
  private String atSchemaLocation;

  @JsonProperty("href")
  private URI href;

  @JsonProperty("id")
  private String id;

  @JsonProperty("name")
  private String name;

  @JsonProperty("documentType")
  private String documentType;

  @JsonProperty("version")
  private String version;

  @JsonProperty("category")
  @Valid
  private List<CategoryRef> category = null;

  @JsonProperty("creationDate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime creationDate;

  @JsonProperty("expiryDate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime expiryDate;

  @JsonProperty("description")
  private String description;

  @JsonProperty("documentRelationship")
  @Valid
  private List<DocumentRefOrValue> documentRelationship = null;

  @JsonProperty("lastUpdate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime lastUpdate;

  @JsonProperty("lifecycleState")
  private String lifecycleState;

  @JsonProperty("attachment")
  @Valid
  private List<Attachment> attachment = null;

  @JsonProperty("characteristic")
  @Valid
  private List<Characteristic> characteristic = null;

  @JsonProperty("relatedEntity")
  private RelatedEntity relatedEntity;

  @JsonProperty("relatedParty")
  @Valid
  private List<RelatedPartyRefOrPartyRoleRef> relatedParty = null;

  @JsonProperty("externalIdentifier")
  @Valid
  private List<ExternalIdentifier> externalIdentifier = null;

  @JsonProperty("validFor")
  private TimePeriod validFor;

  public Document atType(String atType) {
    this.atType = atType;
    return this;
  }

  /**
   * When sub-classing, this defines the sub-class Extensible name
   * @return atType
  */
  @NotNull 
  @Schema(name = "@type", description = "When sub-classing, this defines the sub-class Extensible name", required = true)
  public String getAtType() {
    return atType;
  }

  public void setAtType(String atType) {
    this.atType = atType;
  }

  public Document atBaseType(String atBaseType) {
    this.atBaseType = atBaseType;
    return this;
  }

  /**
   * When sub-classing, this defines the super-class
   * @return atBaseType
  */
  
  @Schema(name = "@baseType", description = "When sub-classing, this defines the super-class", required = false)
  public String getAtBaseType() {
    return atBaseType;
  }

  public void setAtBaseType(String atBaseType) {
    this.atBaseType = atBaseType;
  }

  public Document atSchemaLocation(String atSchemaLocation) {
    this.atSchemaLocation = atSchemaLocation;
    return this;
  }

  /**
   * A URI to a JSON-Schema file that defines additional attributes and relationships
   * @return atSchemaLocation
  */
  
  @Schema(name = "@schemaLocation", description = "A URI to a JSON-Schema file that defines additional attributes and relationships", required = false)
  public String getAtSchemaLocation() {
    return atSchemaLocation;
  }

  public void setAtSchemaLocation(String atSchemaLocation) {
    this.atSchemaLocation = atSchemaLocation;
  }

  public Document href(URI href) {
    this.href = href;
    return this;
  }

  /**
   * Hyperlink reference
   * @return href
  */
  @Valid 
  @Schema(name = "href", description = "Hyperlink reference", required = false)
  public URI getHref() {
    return href;
  }

  public void setHref(URI href) {
    this.href = href;
  }

  public Document id(String id) {
    this.id = id;
    return this;
  }

  /**
   * unique identifier
   * @return id
  */
  
  @Schema(name = "id", description = "unique identifier", required = false)
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public Document name(String name) {
    this.name = name;
    return this;
  }

  /**
   * A string used to give a name to the document
   * @return name
  */
  
  @Schema(name = "name", description = "A string used to give a name to the document", required = false)
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Document documentType(String documentType) {
    this.documentType = documentType;
    return this;
  }

  /**
   * Name of the document type
   * @return documentType
  */
  
  @Schema(name = "documentType", description = "Name of the document type", required = false)
  public String getDocumentType() {
    return documentType;
  }

  public void setDocumentType(String documentType) {
    this.documentType = documentType;
  }

  public Document version(String version) {
    this.version = version;
    return this;
  }

  /**
   * A particular form or variety of an artefact that is different from others or from the original. The form represents differences in properties that characterize an artefact, that are not enough to warrant creating a new artefact
   * @return version
  */
  
  @Schema(name = "version", description = "A particular form or variety of an artefact that is different from others or from the original. The form represents differences in properties that characterize an artefact, that are not enough to warrant creating a new artefact", required = false)
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public Document category(List<CategoryRef> category) {
    this.category = category;
    return this;
  }

  public Document addCategoryItem(CategoryRef categoryItem) {
    if (this.category == null) {
      this.category = new ArrayList<>();
    }
    this.category.add(categoryItem);
    return this;
  }

  /**
   * Collection of categories applicable
   * @return category
  */
  @Valid 
  @Schema(name = "category", description = "Collection of categories applicable", required = false)
  public List<CategoryRef> getCategory() {
    return category;
  }

  public void setCategory(List<CategoryRef> category) {
    this.category = category;
  }

  public Document creationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * The date and time the document was created. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return creationDate
  */
  @Valid 
  @Schema(name = "creationDate", description = "The date and time the document was created. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }

  public void setCreationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
  }

  public Document expiryDate(OffsetDateTime expiryDate) {
    this.expiryDate = expiryDate;
    return this;
  }

  /**
   * The date and time the document is to expire. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return expiryDate
  */
  @Valid 
  @Schema(name = "expiryDate", description = "The date and time the document is to expire. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getExpiryDate() {
    return expiryDate;
  }

  public void setExpiryDate(OffsetDateTime expiryDate) {
    this.expiryDate = expiryDate;
  }

  public Document description(String description) {
    this.description = description;
    return this;
  }

  /**
   * free-text description of the document
   * @return description
  */
  
  @Schema(name = "description", description = "free-text description of the document", required = false)
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public Document documentRelationship(List<DocumentRefOrValue> documentRelationship) {
    this.documentRelationship = documentRelationship;
    return this;
  }

  public Document addDocumentRelationshipItem(DocumentRefOrValue documentRelationshipItem) {
    if (this.documentRelationship == null) {
      this.documentRelationship = new ArrayList<>();
    }
    this.documentRelationship.add(documentRelationshipItem);
    return this;
  }

  /**
   * A collection of document elements
   * @return documentRelationship
  */
  @Valid 
  @Schema(name = "documentRelationship", description = "A collection of document elements", required = false)
  public List<DocumentRefOrValue> getDocumentRelationship() {
    return documentRelationship;
  }

  public void setDocumentRelationship(List<DocumentRefOrValue> documentRelationship) {
    this.documentRelationship = documentRelationship;
  }

  public Document lastUpdate(OffsetDateTime lastUpdate) {
    this.lastUpdate = lastUpdate;
    return this;
  }

  /**
   * The date and time the document was last modified. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return lastUpdate
  */
  @Valid 
  @Schema(name = "lastUpdate", description = "The date and time the document was last modified. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getLastUpdate() {
    return lastUpdate;
  }

  public void setLastUpdate(OffsetDateTime lastUpdate) {
    this.lastUpdate = lastUpdate;
  }

  public Document lifecycleState(String lifecycleState) {
    this.lifecycleState = lifecycleState;
    return this;
  }

  /**
   * Represents the lifecycleState of the document.
   * @return lifecycleState
  */
  
  @Schema(name = "lifecycleState", description = "Represents the lifecycleState of the document.", required = false)
  public String getLifecycleState() {
    return lifecycleState;
  }

  public void setLifecycleState(String lifecycleState) {
    this.lifecycleState = lifecycleState;
  }

  public Document attachment(List<Attachment> attachment) {
    this.attachment = attachment;
    return this;
  }

  public Document addAttachmentItem(Attachment attachmentItem) {
    if (this.attachment == null) {
      this.attachment = new ArrayList<>();
    }
    this.attachment.add(attachmentItem);
    return this;
  }

  /**
   * Collection of attachments
   * @return attachment
  */
  @Valid 
  @Schema(name = "attachment", description = "Collection of attachments", required = false)
  public List<Attachment> getAttachment() {
    return attachment;
  }

  public void setAttachment(List<Attachment> attachment) {
    this.attachment = attachment;
  }

  public Document characteristic(List<Characteristic> characteristic) {
    this.characteristic = characteristic;
    return this;
  }

  public Document addCharacteristicItem(Characteristic characteristicItem) {
    if (this.characteristic == null) {
      this.characteristic = new ArrayList<>();
    }
    this.characteristic.add(characteristicItem);
    return this;
  }

  /**
   * Collection of characteristics
   * @return characteristic
  */
  @Valid 
  @Schema(name = "characteristic", description = "Collection of characteristics", required = false)
  public List<Characteristic> getCharacteristic() {
    return characteristic;
  }

  public void setCharacteristic(List<Characteristic> characteristic) {
    this.characteristic = characteristic;
  }

  public Document relatedEntity(RelatedEntity relatedEntity) {
    this.relatedEntity = relatedEntity;
    return this;
  }

  /**
   * Get relatedEntity
   * @return relatedEntity
  */
  @Valid 
  @Schema(name = "relatedEntity", required = false)
  public RelatedEntity getRelatedEntity() {
    return relatedEntity;
  }

  public void setRelatedEntity(RelatedEntity relatedEntity) {
    this.relatedEntity = relatedEntity;
  }

  public Document relatedParty(List<RelatedPartyRefOrPartyRoleRef> relatedParty) {
    this.relatedParty = relatedParty;
    return this;
  }

  public Document addRelatedPartyItem(RelatedPartyRefOrPartyRoleRef relatedPartyItem) {
    if (this.relatedParty == null) {
      this.relatedParty = new ArrayList<>();
    }
    this.relatedParty.add(relatedPartyItem);
    return this;
  }

  /**
   * A collection of related parties
   * @return relatedParty
  */
  @Valid 
  @Schema(name = "relatedParty", description = "A collection of related parties", required = false)
  public List<RelatedPartyRefOrPartyRoleRef> getRelatedParty() {
    return relatedParty;
  }

  public void setRelatedParty(List<RelatedPartyRefOrPartyRoleRef> relatedParty) {
    this.relatedParty = relatedParty;
  }

  public Document externalIdentifier(List<ExternalIdentifier> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
    return this;
  }

  public Document addExternalIdentifierItem(ExternalIdentifier externalIdentifierItem) {
    if (this.externalIdentifier == null) {
      this.externalIdentifier = new ArrayList<>();
    }
    this.externalIdentifier.add(externalIdentifierItem);
    return this;
  }

  /**
   * Collection of external identifiers
   * @return externalIdentifier
  */
  @Valid 
  @Schema(name = "externalIdentifier", description = "Collection of external identifiers", required = false)
  public List<ExternalIdentifier> getExternalIdentifier() {
    return externalIdentifier;
  }

  public void setExternalIdentifier(List<ExternalIdentifier> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
  }

  public Document validFor(TimePeriod validFor) {
    this.validFor = validFor;
    return this;
  }

  /**
   * Get validFor
   * @return validFor
  */
  @Valid 
  @Schema(name = "validFor", required = false)
  public TimePeriod getValidFor() {
    return validFor;
  }

  public void setValidFor(TimePeriod validFor) {
    this.validFor = validFor;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Document document = (Document) o;
    return Objects.equals(this.atType, document.atType) &&
        Objects.equals(this.atBaseType, document.atBaseType) &&
        Objects.equals(this.atSchemaLocation, document.atSchemaLocation) &&
        Objects.equals(this.href, document.href) &&
        Objects.equals(this.id, document.id) &&
        Objects.equals(this.name, document.name) &&
        Objects.equals(this.documentType, document.documentType) &&
        Objects.equals(this.version, document.version) &&
        Objects.equals(this.category, document.category) &&
        Objects.equals(this.creationDate, document.creationDate) &&
        Objects.equals(this.expiryDate, document.expiryDate) &&
        Objects.equals(this.description, document.description) &&
        Objects.equals(this.documentRelationship, document.documentRelationship) &&
        Objects.equals(this.lastUpdate, document.lastUpdate) &&
        Objects.equals(this.lifecycleState, document.lifecycleState) &&
        Objects.equals(this.attachment, document.attachment) &&
        Objects.equals(this.characteristic, document.characteristic) &&
        Objects.equals(this.relatedEntity, document.relatedEntity) &&
        Objects.equals(this.relatedParty, document.relatedParty) &&
        Objects.equals(this.externalIdentifier, document.externalIdentifier) &&
        Objects.equals(this.validFor, document.validFor);
  }

  @Override
  public int hashCode() {
    return Objects.hash(atType, atBaseType, atSchemaLocation, href, id, name, documentType, version, category, creationDate, expiryDate, description, documentRelationship, lastUpdate, lifecycleState, attachment, characteristic, relatedEntity, relatedParty, externalIdentifier, validFor);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Document {\n");
    sb.append("    atType: ").append(toIndentedString(atType)).append("\n");
    sb.append("    atBaseType: ").append(toIndentedString(atBaseType)).append("\n");
    sb.append("    atSchemaLocation: ").append(toIndentedString(atSchemaLocation)).append("\n");
    sb.append("    href: ").append(toIndentedString(href)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    documentType: ").append(toIndentedString(documentType)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    expiryDate: ").append(toIndentedString(expiryDate)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    documentRelationship: ").append(toIndentedString(documentRelationship)).append("\n");
    sb.append("    lastUpdate: ").append(toIndentedString(lastUpdate)).append("\n");
    sb.append("    lifecycleState: ").append(toIndentedString(lifecycleState)).append("\n");
    sb.append("    attachment: ").append(toIndentedString(attachment)).append("\n");
    sb.append("    characteristic: ").append(toIndentedString(characteristic)).append("\n");
    sb.append("    relatedEntity: ").append(toIndentedString(relatedEntity)).append("\n");
    sb.append("    relatedParty: ").append(toIndentedString(relatedParty)).append("\n");
    sb.append("    externalIdentifier: ").append(toIndentedString(externalIdentifier)).append("\n");
    sb.append("    validFor: ").append(toIndentedString(validFor)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

