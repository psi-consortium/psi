package com.cgi.space.psi.common.model;

import java.net.URI;
import java.util.Objects;
import com.cgi.space.psi.common.model.ExternalIdentifierMVO;
import com.cgi.space.psi.common.model.GeographicAddressMVO;
import com.cgi.space.psi.common.model.GeographicLocationMVO;
import com.cgi.space.psi.common.model.GeographicLocationRefOrValueMVO;
import com.cgi.space.psi.common.model.GeographicSiteMVO;
import com.cgi.space.psi.common.model.GeographicSubAddressMVO;
import com.cgi.space.psi.common.model.PlaceMVO;
import com.cgi.space.psi.common.model.StandardIdentifierMVO;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.util.ArrayList;
import java.util.List;
import java.math.BigDecimal;
import java.net.URI;
import java.time.OffsetDateTime;
import org.springframework.format.annotation.DateTimeFormat;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;


import java.util.*;
import javax.annotation.Generated;

/**
 * GeographicAddressMVO
 */
@com.fasterxml.jackson.annotation.JsonFilter(com.cgi.space.psi.common.config.DynamicJacksonFilterProvider.NAME)

@JsonIgnoreProperties(
  value = "@type", // ignore manually set @type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the @type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "@type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = GeographicAddressMVO.class, name = "GeographicAddress"),
  @JsonSubTypes.Type(value = GeographicLocationMVO.class, name = "GeographicLocation"),
  @JsonSubTypes.Type(value = GeographicSiteMVO.class, name = "GeographicSite"),
  @JsonSubTypes.Type(value = PlaceMVO.class, name = "Place")
})

@JsonTypeName("GeographicAddress_MVO")
@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
public class GeographicAddressMVO extends PlaceMVO implements PlaceRefOrValueMVO {

  @JsonProperty("city")
  private String city;

  @JsonProperty("country")
  private String country;

  @JsonProperty("locality")
  private String locality;

  @JsonProperty("postcode")
  private String postcode;

  @JsonProperty("stateOrProvince")
  private String stateOrProvince;

  @JsonProperty("streetName")
  private String streetName;

  @JsonProperty("streetNr")
  private String streetNr;

  @JsonProperty("streetNrLast")
  private String streetNrLast;

  @JsonProperty("streetNrLastSuffix")
  private String streetNrLastSuffix;

  @JsonProperty("streetNrSuffix")
  private String streetNrSuffix;

  @JsonProperty("streetSuffix")
  private String streetSuffix;

  @JsonProperty("streetType")
  private String streetType;

  @JsonProperty("countryCode")
  @Valid
  private List<StandardIdentifierMVO> countryCode = null;

  @JsonProperty("externalIdentifier")
  @Valid
  private List<ExternalIdentifierMVO> externalIdentifier = null;

  @JsonProperty("geographicLocation")
  private GeographicLocationRefOrValueMVO geographicLocation;

  @JsonProperty("geographicSubAddress")
  @Valid
  private List<GeographicSubAddressMVO> geographicSubAddress = null;

  @JsonProperty("geographicAddressType")
  private String geographicAddressType;

  public GeographicAddressMVO city(String city) {
    this.city = city;
    return this;
  }

  /**
   * City that the address is in
   * @return city
  */
  
  @Schema(name = "city", description = "City that the address is in", required = false)
  public String getCity() {
    return city;
  }

  public void setCity(String city) {
    this.city = city;
  }

  public GeographicAddressMVO country(String country) {
    this.country = country;
    return this;
  }

  /**
   * Country that the address is in
   * @return country
  */
  
  @Schema(name = "country", description = "Country that the address is in", required = false)
  public String getCountry() {
    return country;
  }

  public void setCountry(String country) {
    this.country = country;
  }

  public GeographicAddressMVO locality(String locality) {
    this.locality = locality;
    return this;
  }

  /**
   * An area of defined or undefined boundaries within a local authority or other legislatively defined area, usually rural or semi rural in nature. [ANZLIC-STREET], or a suburb, a bounded locality within a city, town or shire principally of urban character [ANZLICSTREET]
   * @return locality
  */
  
  @Schema(name = "locality", description = "An area of defined or undefined boundaries within a local authority or other legislatively defined area, usually rural or semi rural in nature. [ANZLIC-STREET], or a suburb, a bounded locality within a city, town or shire principally of urban character [ANZLICSTREET]", required = false)
  public String getLocality() {
    return locality;
  }

  public void setLocality(String locality) {
    this.locality = locality;
  }

  public GeographicAddressMVO postcode(String postcode) {
    this.postcode = postcode;
    return this;
  }

  /**
   * descriptor for a postal delivery area, used to speed and simplify the delivery of mail (also know as zipcode)
   * @return postcode
  */
  
  @Schema(name = "postcode", description = "descriptor for a postal delivery area, used to speed and simplify the delivery of mail (also know as zipcode)", required = false)
  public String getPostcode() {
    return postcode;
  }

  public void setPostcode(String postcode) {
    this.postcode = postcode;
  }

  public GeographicAddressMVO stateOrProvince(String stateOrProvince) {
    this.stateOrProvince = stateOrProvince;
    return this;
  }

  /**
   * the State or Province that the address is in
   * @return stateOrProvince
  */
  
  @Schema(name = "stateOrProvince", description = "the State or Province that the address is in", required = false)
  public String getStateOrProvince() {
    return stateOrProvince;
  }

  public void setStateOrProvince(String stateOrProvince) {
    this.stateOrProvince = stateOrProvince;
  }

  public GeographicAddressMVO streetName(String streetName) {
    this.streetName = streetName;
    return this;
  }

  /**
   * Name of the street or other street type
   * @return streetName
  */
  
  @Schema(name = "streetName", description = "Name of the street or other street type", required = false)
  public String getStreetName() {
    return streetName;
  }

  public void setStreetName(String streetName) {
    this.streetName = streetName;
  }

  public GeographicAddressMVO streetNr(String streetNr) {
    this.streetNr = streetNr;
    return this;
  }

  /**
   * Number identifying a specific property on a public street. It may be combined with streetNrLast for ranged addresses
   * @return streetNr
  */
  
  @Schema(name = "streetNr", description = "Number identifying a specific property on a public street. It may be combined with streetNrLast for ranged addresses", required = false)
  public String getStreetNr() {
    return streetNr;
  }

  public void setStreetNr(String streetNr) {
    this.streetNr = streetNr;
  }

  public GeographicAddressMVO streetNrLast(String streetNrLast) {
    this.streetNrLast = streetNrLast;
    return this;
  }

  /**
   * Last number in a range of street numbers allocated to a property
   * @return streetNrLast
  */
  
  @Schema(name = "streetNrLast", description = "Last number in a range of street numbers allocated to a property", required = false)
  public String getStreetNrLast() {
    return streetNrLast;
  }

  public void setStreetNrLast(String streetNrLast) {
    this.streetNrLast = streetNrLast;
  }

  public GeographicAddressMVO streetNrLastSuffix(String streetNrLastSuffix) {
    this.streetNrLastSuffix = streetNrLastSuffix;
    return this;
  }

  /**
   * Last street number suffix for a ranged address
   * @return streetNrLastSuffix
  */
  
  @Schema(name = "streetNrLastSuffix", description = "Last street number suffix for a ranged address", required = false)
  public String getStreetNrLastSuffix() {
    return streetNrLastSuffix;
  }

  public void setStreetNrLastSuffix(String streetNrLastSuffix) {
    this.streetNrLastSuffix = streetNrLastSuffix;
  }

  public GeographicAddressMVO streetNrSuffix(String streetNrSuffix) {
    this.streetNrSuffix = streetNrSuffix;
    return this;
  }

  /**
   * the first street number suffix
   * @return streetNrSuffix
  */
  
  @Schema(name = "streetNrSuffix", description = "the first street number suffix", required = false)
  public String getStreetNrSuffix() {
    return streetNrSuffix;
  }

  public void setStreetNrSuffix(String streetNrSuffix) {
    this.streetNrSuffix = streetNrSuffix;
  }

  public GeographicAddressMVO streetSuffix(String streetSuffix) {
    this.streetSuffix = streetSuffix;
    return this;
  }

  /**
   * A modifier denoting a relative direction
   * @return streetSuffix
  */
  
  @Schema(name = "streetSuffix", description = "A modifier denoting a relative direction", required = false)
  public String getStreetSuffix() {
    return streetSuffix;
  }

  public void setStreetSuffix(String streetSuffix) {
    this.streetSuffix = streetSuffix;
  }

  public GeographicAddressMVO streetType(String streetType) {
    this.streetType = streetType;
    return this;
  }

  /**
   * alley, avenue, boulevard, brae, crescent, drive, highway, lane, terrace, parade, place, tarn, way, wharf 
   * @return streetType
  */
  
  @Schema(name = "streetType", description = "alley, avenue, boulevard, brae, crescent, drive, highway, lane, terrace, parade, place, tarn, way, wharf ", required = false)
  public String getStreetType() {
    return streetType;
  }

  public void setStreetType(String streetType) {
    this.streetType = streetType;
  }

  public GeographicAddressMVO countryCode(List<StandardIdentifierMVO> countryCode) {
    this.countryCode = countryCode;
    return this;
  }

  public GeographicAddressMVO addCountryCodeItem(StandardIdentifierMVO countryCodeItem) {
    if (this.countryCode == null) {
      this.countryCode = new ArrayList<>();
    }
    this.countryCode.add(countryCodeItem);
    return this;
  }

  /**
   * Country codes are short alphabetic or numeric geographical codes (geocodes) developed to represent countries and dependent areas, for use in data processing and communications. Several different systems have been developed to do this. The term country code frequently refers to ISO 3166-1 alpha-2 or international dialing codes, the E.164 country calling codes.
   * @return countryCode
  */
  @Valid 
  @Schema(name = "countryCode", description = "Country codes are short alphabetic or numeric geographical codes (geocodes) developed to represent countries and dependent areas, for use in data processing and communications. Several different systems have been developed to do this. The term country code frequently refers to ISO 3166-1 alpha-2 or international dialing codes, the E.164 country calling codes.", required = false)
  public List<StandardIdentifierMVO> getCountryCode() {
    return countryCode;
  }

  public void setCountryCode(List<StandardIdentifierMVO> countryCode) {
    this.countryCode = countryCode;
  }

  public GeographicAddressMVO externalIdentifier(List<ExternalIdentifierMVO> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
    return this;
  }

  public GeographicAddressMVO addExternalIdentifierItem(ExternalIdentifierMVO externalIdentifierItem) {
    if (this.externalIdentifier == null) {
      this.externalIdentifier = new ArrayList<>();
    }
    this.externalIdentifier.add(externalIdentifierItem);
    return this;
  }

  /**
   * Get externalIdentifier
   * @return externalIdentifier
  */
  @Valid 
  @Schema(name = "externalIdentifier", required = false)
  public List<ExternalIdentifierMVO> getExternalIdentifier() {
    return externalIdentifier;
  }

  public void setExternalIdentifier(List<ExternalIdentifierMVO> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
  }

  public GeographicAddressMVO geographicLocation(GeographicLocationRefOrValueMVO geographicLocation) {
    this.geographicLocation = geographicLocation;
    return this;
  }

  /**
   * Get geographicLocation
   * @return geographicLocation
  */
  @Valid 
  @Schema(name = "geographicLocation", required = false)
  public GeographicLocationRefOrValueMVO getGeographicLocation() {
    return geographicLocation;
  }

  public void setGeographicLocation(GeographicLocationRefOrValueMVO geographicLocation) {
    this.geographicLocation = geographicLocation;
  }

  public GeographicAddressMVO geographicSubAddress(List<GeographicSubAddressMVO> geographicSubAddress) {
    this.geographicSubAddress = geographicSubAddress;
    return this;
  }

  public GeographicAddressMVO addGeographicSubAddressItem(GeographicSubAddressMVO geographicSubAddressItem) {
    if (this.geographicSubAddress == null) {
      this.geographicSubAddress = new ArrayList<>();
    }
    this.geographicSubAddress.add(geographicSubAddressItem);
    return this;
  }

  /**
   * Get geographicSubAddress
   * @return geographicSubAddress
  */
  @Valid 
  @Schema(name = "geographicSubAddress", required = false)
  public List<GeographicSubAddressMVO> getGeographicSubAddress() {
    return geographicSubAddress;
  }

  public void setGeographicSubAddress(List<GeographicSubAddressMVO> geographicSubAddress) {
    this.geographicSubAddress = geographicSubAddress;
  }

  public GeographicAddressMVO geographicAddressType(String geographicAddressType) {
    this.geographicAddressType = geographicAddressType;
    return this;
  }

  /**
   * Classification of the address, e.g., residential, industrial 
   * @return geographicAddressType
  */
  
  @Schema(name = "geographicAddressType", description = "Classification of the address, e.g., residential, industrial ", required = false)
  public String getGeographicAddressType() {
    return geographicAddressType;
  }

  public void setGeographicAddressType(String geographicAddressType) {
    this.geographicAddressType = geographicAddressType;
  }

  public GeographicAddressMVO atType(String atType) {
    super.setAtType(atType);
    return this;
  }

  public GeographicAddressMVO atBaseType(String atBaseType) {
    super.setAtBaseType(atBaseType);
    return this;
  }

  public GeographicAddressMVO atSchemaLocation(String atSchemaLocation) {
    super.setAtSchemaLocation(atSchemaLocation);
    return this;
  }

  public GeographicAddressMVO name(String name) {
    super.setName(name);
    return this;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GeographicAddressMVO geographicAddressMVO = (GeographicAddressMVO) o;
    return Objects.equals(this.city, geographicAddressMVO.city) &&
        Objects.equals(this.country, geographicAddressMVO.country) &&
        Objects.equals(this.locality, geographicAddressMVO.locality) &&
        Objects.equals(this.postcode, geographicAddressMVO.postcode) &&
        Objects.equals(this.stateOrProvince, geographicAddressMVO.stateOrProvince) &&
        Objects.equals(this.streetName, geographicAddressMVO.streetName) &&
        Objects.equals(this.streetNr, geographicAddressMVO.streetNr) &&
        Objects.equals(this.streetNrLast, geographicAddressMVO.streetNrLast) &&
        Objects.equals(this.streetNrLastSuffix, geographicAddressMVO.streetNrLastSuffix) &&
        Objects.equals(this.streetNrSuffix, geographicAddressMVO.streetNrSuffix) &&
        Objects.equals(this.streetSuffix, geographicAddressMVO.streetSuffix) &&
        Objects.equals(this.streetType, geographicAddressMVO.streetType) &&
        Objects.equals(this.countryCode, geographicAddressMVO.countryCode) &&
        Objects.equals(this.externalIdentifier, geographicAddressMVO.externalIdentifier) &&
        Objects.equals(this.geographicLocation, geographicAddressMVO.geographicLocation) &&
        Objects.equals(this.geographicSubAddress, geographicAddressMVO.geographicSubAddress) &&
        Objects.equals(this.geographicAddressType, geographicAddressMVO.geographicAddressType) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(city, country, locality, postcode, stateOrProvince, streetName, streetNr, streetNrLast, streetNrLastSuffix, streetNrSuffix, streetSuffix, streetType, countryCode, externalIdentifier, geographicLocation, geographicSubAddress, geographicAddressType, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GeographicAddressMVO {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    locality: ").append(toIndentedString(locality)).append("\n");
    sb.append("    postcode: ").append(toIndentedString(postcode)).append("\n");
    sb.append("    stateOrProvince: ").append(toIndentedString(stateOrProvince)).append("\n");
    sb.append("    streetName: ").append(toIndentedString(streetName)).append("\n");
    sb.append("    streetNr: ").append(toIndentedString(streetNr)).append("\n");
    sb.append("    streetNrLast: ").append(toIndentedString(streetNrLast)).append("\n");
    sb.append("    streetNrLastSuffix: ").append(toIndentedString(streetNrLastSuffix)).append("\n");
    sb.append("    streetNrSuffix: ").append(toIndentedString(streetNrSuffix)).append("\n");
    sb.append("    streetSuffix: ").append(toIndentedString(streetSuffix)).append("\n");
    sb.append("    streetType: ").append(toIndentedString(streetType)).append("\n");
    sb.append("    countryCode: ").append(toIndentedString(countryCode)).append("\n");
    sb.append("    externalIdentifier: ").append(toIndentedString(externalIdentifier)).append("\n");
    sb.append("    geographicLocation: ").append(toIndentedString(geographicLocation)).append("\n");
    sb.append("    geographicSubAddress: ").append(toIndentedString(geographicSubAddress)).append("\n");
    sb.append("    geographicAddressType: ").append(toIndentedString(geographicAddressType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

