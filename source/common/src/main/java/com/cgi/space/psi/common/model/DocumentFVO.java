package com.cgi.space.psi.common.model;

import java.net.URI;
import java.util.Objects;
import com.cgi.space.psi.common.model.CategoryRefFVO;
import com.cgi.space.psi.common.model.CharacteristicFVO;
import com.cgi.space.psi.common.model.DocumentFVO;
import com.cgi.space.psi.common.model.DocumentRefOrValueFVO;
import com.cgi.space.psi.common.model.ExternalIdentifierFVO;
import com.cgi.space.psi.common.model.RelatedEntityFVO;
import com.cgi.space.psi.common.model.RelatedPartyRefOrPartyRoleRefFVO;
import com.cgi.space.psi.common.model.TimePeriod;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.springframework.format.annotation.DateTimeFormat;
import java.net.URI;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;


import java.util.*;
import javax.annotation.Generated;

/**
 * DocumentFVO
 */
@com.fasterxml.jackson.annotation.JsonFilter(com.cgi.space.psi.common.config.DynamicJacksonFilterProvider.NAME)

@JsonIgnoreProperties(
  value = "@type", // ignore manually set @type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the @type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "@type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = DocumentFVO.class, name = "Document")
})

@JsonTypeName("Document_FVO")
@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
public class DocumentFVO implements DocumentRefOrValueFVO {

  @JsonProperty("@type")
  private String atType;

  @JsonProperty("@baseType")
  private String atBaseType;

  @JsonProperty("@schemaLocation")
  private String atSchemaLocation;

  @JsonProperty("id")
  private String id;

  @JsonProperty("name")
  private String name;

  @JsonProperty("documentType")
  private String documentType;

  @JsonProperty("version")
  private String version;

  @JsonProperty("category")
  @Valid
  private List<CategoryRefFVO> category = null;

  @JsonProperty("creationDate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime creationDate;

  @JsonProperty("expiryDate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime expiryDate;

  @JsonProperty("description")
  private String description;

  @JsonProperty("documentRelationship")
  @Valid
  private List<DocumentRefOrValueFVO> documentRelationship = null;

  @JsonProperty("lastUpdate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime lastUpdate;

  @JsonProperty("lifecycleState")
  private String lifecycleState;

  @JsonProperty("characteristic")
  @Valid
  private List<CharacteristicFVO> characteristic = null;

  @JsonProperty("relatedEntity")
  private RelatedEntityFVO relatedEntity;

  @JsonProperty("relatedParty")
  @Valid
  private List<RelatedPartyRefOrPartyRoleRefFVO> relatedParty = null;

  @JsonProperty("externalIdentifier")
  @Valid
  private List<ExternalIdentifierFVO> externalIdentifier = null;

  @JsonProperty("validFor")
  private TimePeriod validFor;

  public DocumentFVO atType(String atType) {
    this.atType = atType;
    return this;
  }

  /**
   * When sub-classing, this defines the sub-class Extensible name
   * @return atType
  */
  @NotNull 
  @Schema(name = "@type", description = "When sub-classing, this defines the sub-class Extensible name", required = true)
  public String getAtType() {
    return atType;
  }

  public void setAtType(String atType) {
    this.atType = atType;
  }

  public DocumentFVO atBaseType(String atBaseType) {
    this.atBaseType = atBaseType;
    return this;
  }

  /**
   * When sub-classing, this defines the super-class
   * @return atBaseType
  */
  
  @Schema(name = "@baseType", description = "When sub-classing, this defines the super-class", required = false)
  public String getAtBaseType() {
    return atBaseType;
  }

  public void setAtBaseType(String atBaseType) {
    this.atBaseType = atBaseType;
  }

  public DocumentFVO atSchemaLocation(String atSchemaLocation) {
    this.atSchemaLocation = atSchemaLocation;
    return this;
  }

  /**
   * A URI to a JSON-Schema file that defines additional attributes and relationships
   * @return atSchemaLocation
  */
  
  @Schema(name = "@schemaLocation", description = "A URI to a JSON-Schema file that defines additional attributes and relationships", required = false)
  public String getAtSchemaLocation() {
    return atSchemaLocation;
  }

  public void setAtSchemaLocation(String atSchemaLocation) {
    this.atSchemaLocation = atSchemaLocation;
  }

  public DocumentFVO id(String id) {
    this.id = id;
    return this;
  }

  /**
   * unique identifier
   * @return id
  */
  
  @Schema(name = "id", description = "unique identifier", required = false)
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public DocumentFVO name(String name) {
    this.name = name;
    return this;
  }

  /**
   * A string used to give a name to the document
   * @return name
  */
  @NotNull 
  @Schema(name = "name", description = "A string used to give a name to the document", required = true)
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public DocumentFVO documentType(String documentType) {
    this.documentType = documentType;
    return this;
  }

  /**
   * Name of the document type
   * @return documentType
  */
  
  @Schema(name = "documentType", description = "Name of the document type", required = false)
  public String getDocumentType() {
    return documentType;
  }

  public void setDocumentType(String documentType) {
    this.documentType = documentType;
  }

  public DocumentFVO version(String version) {
    this.version = version;
    return this;
  }

  /**
   * A particular form or variety of an artefact that is different from others or from the original. The form represents differences in properties that characterize an artefact, that are not enough to warrant creating a new artefact
   * @return version
  */
  
  @Schema(name = "version", description = "A particular form or variety of an artefact that is different from others or from the original. The form represents differences in properties that characterize an artefact, that are not enough to warrant creating a new artefact", required = false)
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public DocumentFVO category(List<CategoryRefFVO> category) {
    this.category = category;
    return this;
  }

  public DocumentFVO addCategoryItem(CategoryRefFVO categoryItem) {
    if (this.category == null) {
      this.category = new ArrayList<>();
    }
    this.category.add(categoryItem);
    return this;
  }

  /**
   * Collection of categories applicable
   * @return category
  */
  @Valid 
  @Schema(name = "category", description = "Collection of categories applicable", required = false)
  public List<CategoryRefFVO> getCategory() {
    return category;
  }

  public void setCategory(List<CategoryRefFVO> category) {
    this.category = category;
  }

  public DocumentFVO creationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * The date and time the document was created. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return creationDate
  */
  @Valid 
  @Schema(name = "creationDate", description = "The date and time the document was created. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }

  public void setCreationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
  }

  public DocumentFVO expiryDate(OffsetDateTime expiryDate) {
    this.expiryDate = expiryDate;
    return this;
  }

  /**
   * The date and time the document is to expire. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return expiryDate
  */
  @Valid 
  @Schema(name = "expiryDate", description = "The date and time the document is to expire. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getExpiryDate() {
    return expiryDate;
  }

  public void setExpiryDate(OffsetDateTime expiryDate) {
    this.expiryDate = expiryDate;
  }

  public DocumentFVO description(String description) {
    this.description = description;
    return this;
  }

  /**
   * free-text description of the document
   * @return description
  */
  
  @Schema(name = "description", description = "free-text description of the document", required = false)
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public DocumentFVO documentRelationship(List<DocumentRefOrValueFVO> documentRelationship) {
    this.documentRelationship = documentRelationship;
    return this;
  }

  public DocumentFVO addDocumentRelationshipItem(DocumentRefOrValueFVO documentRelationshipItem) {
    if (this.documentRelationship == null) {
      this.documentRelationship = new ArrayList<>();
    }
    this.documentRelationship.add(documentRelationshipItem);
    return this;
  }

  /**
   * A collection of document elements
   * @return documentRelationship
  */
  @Valid 
  @Schema(name = "documentRelationship", description = "A collection of document elements", required = false)
  public List<DocumentRefOrValueFVO> getDocumentRelationship() {
    return documentRelationship;
  }

  public void setDocumentRelationship(List<DocumentRefOrValueFVO> documentRelationship) {
    this.documentRelationship = documentRelationship;
  }

  public DocumentFVO lastUpdate(OffsetDateTime lastUpdate) {
    this.lastUpdate = lastUpdate;
    return this;
  }

  /**
   * The date and time the document was last modified. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return lastUpdate
  */
  @Valid 
  @Schema(name = "lastUpdate", description = "The date and time the document was last modified. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getLastUpdate() {
    return lastUpdate;
  }

  public void setLastUpdate(OffsetDateTime lastUpdate) {
    this.lastUpdate = lastUpdate;
  }

  public DocumentFVO lifecycleState(String lifecycleState) {
    this.lifecycleState = lifecycleState;
    return this;
  }

  /**
   * Represents the lifecycleState of the document.
   * @return lifecycleState
  */
  
  @Schema(name = "lifecycleState", description = "Represents the lifecycleState of the document.", required = false)
  public String getLifecycleState() {
    return lifecycleState;
  }

  public void setLifecycleState(String lifecycleState) {
    this.lifecycleState = lifecycleState;
  }

  public DocumentFVO characteristic(List<CharacteristicFVO> characteristic) {
    this.characteristic = characteristic;
    return this;
  }

  public DocumentFVO addCharacteristicItem(CharacteristicFVO characteristicItem) {
    if (this.characteristic == null) {
      this.characteristic = new ArrayList<>();
    }
    this.characteristic.add(characteristicItem);
    return this;
  }

  /**
   * Collection of characteristics
   * @return characteristic
  */
  @Valid 
  @Schema(name = "characteristic", description = "Collection of characteristics", required = false)
  public List<CharacteristicFVO> getCharacteristic() {
    return characteristic;
  }

  public void setCharacteristic(List<CharacteristicFVO> characteristic) {
    this.characteristic = characteristic;
  }

  public DocumentFVO relatedEntity(RelatedEntityFVO relatedEntity) {
    this.relatedEntity = relatedEntity;
    return this;
  }

  /**
   * Get relatedEntity
   * @return relatedEntity
  */
  @Valid 
  @Schema(name = "relatedEntity", required = false)
  public RelatedEntityFVO getRelatedEntity() {
    return relatedEntity;
  }

  public void setRelatedEntity(RelatedEntityFVO relatedEntity) {
    this.relatedEntity = relatedEntity;
  }

  public DocumentFVO relatedParty(List<RelatedPartyRefOrPartyRoleRefFVO> relatedParty) {
    this.relatedParty = relatedParty;
    return this;
  }

  public DocumentFVO addRelatedPartyItem(RelatedPartyRefOrPartyRoleRefFVO relatedPartyItem) {
    if (this.relatedParty == null) {
      this.relatedParty = new ArrayList<>();
    }
    this.relatedParty.add(relatedPartyItem);
    return this;
  }

  /**
   * A collection of related parties
   * @return relatedParty
  */
  @Valid 
  @Schema(name = "relatedParty", description = "A collection of related parties", required = false)
  public List<RelatedPartyRefOrPartyRoleRefFVO> getRelatedParty() {
    return relatedParty;
  }

  public void setRelatedParty(List<RelatedPartyRefOrPartyRoleRefFVO> relatedParty) {
    this.relatedParty = relatedParty;
  }

  public DocumentFVO externalIdentifier(List<ExternalIdentifierFVO> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
    return this;
  }

  public DocumentFVO addExternalIdentifierItem(ExternalIdentifierFVO externalIdentifierItem) {
    if (this.externalIdentifier == null) {
      this.externalIdentifier = new ArrayList<>();
    }
    this.externalIdentifier.add(externalIdentifierItem);
    return this;
  }

  /**
   * Collection of external identifiers
   * @return externalIdentifier
  */
  @Valid 
  @Schema(name = "externalIdentifier", description = "Collection of external identifiers", required = false)
  public List<ExternalIdentifierFVO> getExternalIdentifier() {
    return externalIdentifier;
  }

  public void setExternalIdentifier(List<ExternalIdentifierFVO> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
  }

  public DocumentFVO validFor(TimePeriod validFor) {
    this.validFor = validFor;
    return this;
  }

  /**
   * Get validFor
   * @return validFor
  */
  @Valid 
  @Schema(name = "validFor", required = false)
  public TimePeriod getValidFor() {
    return validFor;
  }

  public void setValidFor(TimePeriod validFor) {
    this.validFor = validFor;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentFVO documentFVO = (DocumentFVO) o;
    return Objects.equals(this.atType, documentFVO.atType) &&
        Objects.equals(this.atBaseType, documentFVO.atBaseType) &&
        Objects.equals(this.atSchemaLocation, documentFVO.atSchemaLocation) &&
        Objects.equals(this.id, documentFVO.id) &&
        Objects.equals(this.name, documentFVO.name) &&
        Objects.equals(this.documentType, documentFVO.documentType) &&
        Objects.equals(this.version, documentFVO.version) &&
        Objects.equals(this.category, documentFVO.category) &&
        Objects.equals(this.creationDate, documentFVO.creationDate) &&
        Objects.equals(this.expiryDate, documentFVO.expiryDate) &&
        Objects.equals(this.description, documentFVO.description) &&
        Objects.equals(this.documentRelationship, documentFVO.documentRelationship) &&
        Objects.equals(this.lastUpdate, documentFVO.lastUpdate) &&
        Objects.equals(this.lifecycleState, documentFVO.lifecycleState) &&
        Objects.equals(this.characteristic, documentFVO.characteristic) &&
        Objects.equals(this.relatedEntity, documentFVO.relatedEntity) &&
        Objects.equals(this.relatedParty, documentFVO.relatedParty) &&
        Objects.equals(this.externalIdentifier, documentFVO.externalIdentifier) &&
        Objects.equals(this.validFor, documentFVO.validFor);
  }

  @Override
  public int hashCode() {
    return Objects.hash(atType, atBaseType, atSchemaLocation, id, name, documentType, version, category, creationDate, expiryDate, description, documentRelationship, lastUpdate, lifecycleState, characteristic, relatedEntity, relatedParty, externalIdentifier, validFor);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentFVO {\n");
    sb.append("    atType: ").append(toIndentedString(atType)).append("\n");
    sb.append("    atBaseType: ").append(toIndentedString(atBaseType)).append("\n");
    sb.append("    atSchemaLocation: ").append(toIndentedString(atSchemaLocation)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    documentType: ").append(toIndentedString(documentType)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    expiryDate: ").append(toIndentedString(expiryDate)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    documentRelationship: ").append(toIndentedString(documentRelationship)).append("\n");
    sb.append("    lastUpdate: ").append(toIndentedString(lastUpdate)).append("\n");
    sb.append("    lifecycleState: ").append(toIndentedString(lifecycleState)).append("\n");
    sb.append("    characteristic: ").append(toIndentedString(characteristic)).append("\n");
    sb.append("    relatedEntity: ").append(toIndentedString(relatedEntity)).append("\n");
    sb.append("    relatedParty: ").append(toIndentedString(relatedParty)).append("\n");
    sb.append("    externalIdentifier: ").append(toIndentedString(externalIdentifier)).append("\n");
    sb.append("    validFor: ").append(toIndentedString(validFor)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

