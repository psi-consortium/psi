package com.cgi.space.psi.common.model;

import java.net.URI;
import java.util.Objects;
import com.cgi.space.psi.common.model.CategoryRefMVO;
import com.cgi.space.psi.common.model.CharacteristicMVO;
import com.cgi.space.psi.common.model.DocumentMVO;
import com.cgi.space.psi.common.model.DocumentRefOrValueMVO;
import com.cgi.space.psi.common.model.ExternalIdentifierMVO;
import com.cgi.space.psi.common.model.RelatedEntityMVO;
import com.cgi.space.psi.common.model.RelatedPartyRefOrPartyRoleRefMVO;
import com.cgi.space.psi.common.model.TimePeriod;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.springframework.format.annotation.DateTimeFormat;
import java.net.URI;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;


import java.util.*;
import javax.annotation.Generated;

/**
 * DocumentMVO
 */
@com.fasterxml.jackson.annotation.JsonFilter(com.cgi.space.psi.common.config.DynamicJacksonFilterProvider.NAME)

@JsonIgnoreProperties(
  value = "@type", // ignore manually set @type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the @type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "@type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = DocumentMVO.class, name = "Document")
})

@JsonTypeName("Document_MVO")
@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
public class DocumentMVO implements DocumentRefOrValueMVO {

  @JsonProperty("@type")
  private String atType;

  @JsonProperty("@baseType")
  private String atBaseType;

  @JsonProperty("@schemaLocation")
  private String atSchemaLocation;

  @JsonProperty("name")
  private String name;

  @JsonProperty("documentType")
  private String documentType;

  @JsonProperty("version")
  private String version;

  @JsonProperty("category")
  @Valid
  private List<CategoryRefMVO> category = null;

  @JsonProperty("creationDate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime creationDate;

  @JsonProperty("expiryDate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime expiryDate;

  @JsonProperty("description")
  private String description;

  @JsonProperty("documentRelationship")
  @Valid
  private List<DocumentRefOrValueMVO> documentRelationship = null;

  @JsonProperty("lastUpdate")
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
  private OffsetDateTime lastUpdate;

  @JsonProperty("lifecycleState")
  private String lifecycleState;

  @JsonProperty("characteristic")
  @Valid
  private List<CharacteristicMVO> characteristic = null;

  @JsonProperty("relatedEntity")
  private RelatedEntityMVO relatedEntity;

  @JsonProperty("relatedParty")
  @Valid
  private List<RelatedPartyRefOrPartyRoleRefMVO> relatedParty = null;

  @JsonProperty("externalIdentifier")
  @Valid
  private List<ExternalIdentifierMVO> externalIdentifier = null;

  @JsonProperty("validFor")
  private TimePeriod validFor;

  public DocumentMVO atType(String atType) {
    this.atType = atType;
    return this;
  }

  /**
   * When sub-classing, this defines the sub-class Extensible name
   * @return atType
  */
  @NotNull 
  @Schema(name = "@type", description = "When sub-classing, this defines the sub-class Extensible name", required = true)
  public String getAtType() {
    return atType;
  }

  public void setAtType(String atType) {
    this.atType = atType;
  }

  public DocumentMVO atBaseType(String atBaseType) {
    this.atBaseType = atBaseType;
    return this;
  }

  /**
   * When sub-classing, this defines the super-class
   * @return atBaseType
  */
  
  @Schema(name = "@baseType", description = "When sub-classing, this defines the super-class", required = false)
  public String getAtBaseType() {
    return atBaseType;
  }

  public void setAtBaseType(String atBaseType) {
    this.atBaseType = atBaseType;
  }

  public DocumentMVO atSchemaLocation(String atSchemaLocation) {
    this.atSchemaLocation = atSchemaLocation;
    return this;
  }

  /**
   * A URI to a JSON-Schema file that defines additional attributes and relationships
   * @return atSchemaLocation
  */
  
  @Schema(name = "@schemaLocation", description = "A URI to a JSON-Schema file that defines additional attributes and relationships", required = false)
  public String getAtSchemaLocation() {
    return atSchemaLocation;
  }

  public void setAtSchemaLocation(String atSchemaLocation) {
    this.atSchemaLocation = atSchemaLocation;
  }

  public DocumentMVO name(String name) {
    this.name = name;
    return this;
  }

  /**
   * A string used to give a name to the document
   * @return name
  */
  
  @Schema(name = "name", description = "A string used to give a name to the document", required = false)
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public DocumentMVO documentType(String documentType) {
    this.documentType = documentType;
    return this;
  }

  /**
   * Name of the document type
   * @return documentType
  */
  
  @Schema(name = "documentType", description = "Name of the document type", required = false)
  public String getDocumentType() {
    return documentType;
  }

  public void setDocumentType(String documentType) {
    this.documentType = documentType;
  }

  public DocumentMVO version(String version) {
    this.version = version;
    return this;
  }

  /**
   * A particular form or variety of an artefact that is different from others or from the original. The form represents differences in properties that characterize an artefact, that are not enough to warrant creating a new artefact
   * @return version
  */
  
  @Schema(name = "version", description = "A particular form or variety of an artefact that is different from others or from the original. The form represents differences in properties that characterize an artefact, that are not enough to warrant creating a new artefact", required = false)
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public DocumentMVO category(List<CategoryRefMVO> category) {
    this.category = category;
    return this;
  }

  public DocumentMVO addCategoryItem(CategoryRefMVO categoryItem) {
    if (this.category == null) {
      this.category = new ArrayList<>();
    }
    this.category.add(categoryItem);
    return this;
  }

  /**
   * Collection of categories applicable
   * @return category
  */
  @Valid 
  @Schema(name = "category", description = "Collection of categories applicable", required = false)
  public List<CategoryRefMVO> getCategory() {
    return category;
  }

  public void setCategory(List<CategoryRefMVO> category) {
    this.category = category;
  }

  public DocumentMVO creationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * The date and time the document was created. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return creationDate
  */
  @Valid 
  @Schema(name = "creationDate", description = "The date and time the document was created. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }

  public void setCreationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
  }

  public DocumentMVO expiryDate(OffsetDateTime expiryDate) {
    this.expiryDate = expiryDate;
    return this;
  }

  /**
   * The date and time the document is to expire. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return expiryDate
  */
  @Valid 
  @Schema(name = "expiryDate", description = "The date and time the document is to expire. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getExpiryDate() {
    return expiryDate;
  }

  public void setExpiryDate(OffsetDateTime expiryDate) {
    this.expiryDate = expiryDate;
  }

  public DocumentMVO description(String description) {
    this.description = description;
    return this;
  }

  /**
   * free-text description of the document
   * @return description
  */
  
  @Schema(name = "description", description = "free-text description of the document", required = false)
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public DocumentMVO documentRelationship(List<DocumentRefOrValueMVO> documentRelationship) {
    this.documentRelationship = documentRelationship;
    return this;
  }

  public DocumentMVO addDocumentRelationshipItem(DocumentRefOrValueMVO documentRelationshipItem) {
    if (this.documentRelationship == null) {
      this.documentRelationship = new ArrayList<>();
    }
    this.documentRelationship.add(documentRelationshipItem);
    return this;
  }

  /**
   * A collection of document elements
   * @return documentRelationship
  */
  @Valid 
  @Schema(name = "documentRelationship", description = "A collection of document elements", required = false)
  public List<DocumentRefOrValueMVO> getDocumentRelationship() {
    return documentRelationship;
  }

  public void setDocumentRelationship(List<DocumentRefOrValueMVO> documentRelationship) {
    this.documentRelationship = documentRelationship;
  }

  public DocumentMVO lastUpdate(OffsetDateTime lastUpdate) {
    this.lastUpdate = lastUpdate;
    return this;
  }

  /**
   * The date and time the document was last modified. A date and time formatted in compliance with the ISO8601 standard must be used.
   * @return lastUpdate
  */
  @Valid 
  @Schema(name = "lastUpdate", description = "The date and time the document was last modified. A date and time formatted in compliance with the ISO8601 standard must be used.", required = false)
  public OffsetDateTime getLastUpdate() {
    return lastUpdate;
  }

  public void setLastUpdate(OffsetDateTime lastUpdate) {
    this.lastUpdate = lastUpdate;
  }

  public DocumentMVO lifecycleState(String lifecycleState) {
    this.lifecycleState = lifecycleState;
    return this;
  }

  /**
   * Represents the lifecycleState of the document.
   * @return lifecycleState
  */
  
  @Schema(name = "lifecycleState", description = "Represents the lifecycleState of the document.", required = false)
  public String getLifecycleState() {
    return lifecycleState;
  }

  public void setLifecycleState(String lifecycleState) {
    this.lifecycleState = lifecycleState;
  }

  public DocumentMVO characteristic(List<CharacteristicMVO> characteristic) {
    this.characteristic = characteristic;
    return this;
  }

  public DocumentMVO addCharacteristicItem(CharacteristicMVO characteristicItem) {
    if (this.characteristic == null) {
      this.characteristic = new ArrayList<>();
    }
    this.characteristic.add(characteristicItem);
    return this;
  }

  /**
   * Collection of characteristics
   * @return characteristic
  */
  @Valid 
  @Schema(name = "characteristic", description = "Collection of characteristics", required = false)
  public List<CharacteristicMVO> getCharacteristic() {
    return characteristic;
  }

  public void setCharacteristic(List<CharacteristicMVO> characteristic) {
    this.characteristic = characteristic;
  }

  public DocumentMVO relatedEntity(RelatedEntityMVO relatedEntity) {
    this.relatedEntity = relatedEntity;
    return this;
  }

  /**
   * Get relatedEntity
   * @return relatedEntity
  */
  @Valid 
  @Schema(name = "relatedEntity", required = false)
  public RelatedEntityMVO getRelatedEntity() {
    return relatedEntity;
  }

  public void setRelatedEntity(RelatedEntityMVO relatedEntity) {
    this.relatedEntity = relatedEntity;
  }

  public DocumentMVO relatedParty(List<RelatedPartyRefOrPartyRoleRefMVO> relatedParty) {
    this.relatedParty = relatedParty;
    return this;
  }

  public DocumentMVO addRelatedPartyItem(RelatedPartyRefOrPartyRoleRefMVO relatedPartyItem) {
    if (this.relatedParty == null) {
      this.relatedParty = new ArrayList<>();
    }
    this.relatedParty.add(relatedPartyItem);
    return this;
  }

  /**
   * A collection of related parties
   * @return relatedParty
  */
  @Valid 
  @Schema(name = "relatedParty", description = "A collection of related parties", required = false)
  public List<RelatedPartyRefOrPartyRoleRefMVO> getRelatedParty() {
    return relatedParty;
  }

  public void setRelatedParty(List<RelatedPartyRefOrPartyRoleRefMVO> relatedParty) {
    this.relatedParty = relatedParty;
  }

  public DocumentMVO externalIdentifier(List<ExternalIdentifierMVO> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
    return this;
  }

  public DocumentMVO addExternalIdentifierItem(ExternalIdentifierMVO externalIdentifierItem) {
    if (this.externalIdentifier == null) {
      this.externalIdentifier = new ArrayList<>();
    }
    this.externalIdentifier.add(externalIdentifierItem);
    return this;
  }

  /**
   * Collection of external identifiers
   * @return externalIdentifier
  */
  @Valid 
  @Schema(name = "externalIdentifier", description = "Collection of external identifiers", required = false)
  public List<ExternalIdentifierMVO> getExternalIdentifier() {
    return externalIdentifier;
  }

  public void setExternalIdentifier(List<ExternalIdentifierMVO> externalIdentifier) {
    this.externalIdentifier = externalIdentifier;
  }

  public DocumentMVO validFor(TimePeriod validFor) {
    this.validFor = validFor;
    return this;
  }

  /**
   * Get validFor
   * @return validFor
  */
  @Valid 
  @Schema(name = "validFor", required = false)
  public TimePeriod getValidFor() {
    return validFor;
  }

  public void setValidFor(TimePeriod validFor) {
    this.validFor = validFor;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentMVO documentMVO = (DocumentMVO) o;
    return Objects.equals(this.atType, documentMVO.atType) &&
        Objects.equals(this.atBaseType, documentMVO.atBaseType) &&
        Objects.equals(this.atSchemaLocation, documentMVO.atSchemaLocation) &&
        Objects.equals(this.name, documentMVO.name) &&
        Objects.equals(this.documentType, documentMVO.documentType) &&
        Objects.equals(this.version, documentMVO.version) &&
        Objects.equals(this.category, documentMVO.category) &&
        Objects.equals(this.creationDate, documentMVO.creationDate) &&
        Objects.equals(this.expiryDate, documentMVO.expiryDate) &&
        Objects.equals(this.description, documentMVO.description) &&
        Objects.equals(this.documentRelationship, documentMVO.documentRelationship) &&
        Objects.equals(this.lastUpdate, documentMVO.lastUpdate) &&
        Objects.equals(this.lifecycleState, documentMVO.lifecycleState) &&
        Objects.equals(this.characteristic, documentMVO.characteristic) &&
        Objects.equals(this.relatedEntity, documentMVO.relatedEntity) &&
        Objects.equals(this.relatedParty, documentMVO.relatedParty) &&
        Objects.equals(this.externalIdentifier, documentMVO.externalIdentifier) &&
        Objects.equals(this.validFor, documentMVO.validFor);
  }

  @Override
  public int hashCode() {
    return Objects.hash(atType, atBaseType, atSchemaLocation, name, documentType, version, category, creationDate, expiryDate, description, documentRelationship, lastUpdate, lifecycleState, characteristic, relatedEntity, relatedParty, externalIdentifier, validFor);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentMVO {\n");
    sb.append("    atType: ").append(toIndentedString(atType)).append("\n");
    sb.append("    atBaseType: ").append(toIndentedString(atBaseType)).append("\n");
    sb.append("    atSchemaLocation: ").append(toIndentedString(atSchemaLocation)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    documentType: ").append(toIndentedString(documentType)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    expiryDate: ").append(toIndentedString(expiryDate)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    documentRelationship: ").append(toIndentedString(documentRelationship)).append("\n");
    sb.append("    lastUpdate: ").append(toIndentedString(lastUpdate)).append("\n");
    sb.append("    lifecycleState: ").append(toIndentedString(lifecycleState)).append("\n");
    sb.append("    characteristic: ").append(toIndentedString(characteristic)).append("\n");
    sb.append("    relatedEntity: ").append(toIndentedString(relatedEntity)).append("\n");
    sb.append("    relatedParty: ").append(toIndentedString(relatedParty)).append("\n");
    sb.append("    externalIdentifier: ").append(toIndentedString(externalIdentifier)).append("\n");
    sb.append("    validFor: ").append(toIndentedString(validFor)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

