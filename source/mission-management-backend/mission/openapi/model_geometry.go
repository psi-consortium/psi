/*
Mission Management

## PSID API Reference: PSID002 - Mission Management  The Mission API enables customers to create, update and delete missions. A mission is composed of one or more teams, their areas of operation and communication needs. The data can be used to issue an inquiry for matching products (see PSID001).

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// Geometry - A GeoJson geometry.
type Geometry struct {
	LineString *LineString
	MultiLineString *MultiLineString
	MultiPoint *MultiPoint
	MultiPolygon *MultiPolygon
	Point *Point
	Polygon *Polygon
}

// LineStringAsGeometry is a convenience function that returns LineString wrapped in Geometry
func LineStringAsGeometry(v *LineString) Geometry {
	return Geometry{
		LineString: v,
	}
}

// MultiLineStringAsGeometry is a convenience function that returns MultiLineString wrapped in Geometry
func MultiLineStringAsGeometry(v *MultiLineString) Geometry {
	return Geometry{
		MultiLineString: v,
	}
}

// MultiPointAsGeometry is a convenience function that returns MultiPoint wrapped in Geometry
func MultiPointAsGeometry(v *MultiPoint) Geometry {
	return Geometry{
		MultiPoint: v,
	}
}

// MultiPolygonAsGeometry is a convenience function that returns MultiPolygon wrapped in Geometry
func MultiPolygonAsGeometry(v *MultiPolygon) Geometry {
	return Geometry{
		MultiPolygon: v,
	}
}

// PointAsGeometry is a convenience function that returns Point wrapped in Geometry
func PointAsGeometry(v *Point) Geometry {
	return Geometry{
		Point: v,
	}
}

// PolygonAsGeometry is a convenience function that returns Polygon wrapped in Geometry
func PolygonAsGeometry(v *Polygon) Geometry {
	return Geometry{
		Polygon: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *Geometry) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into LineString
	err = newStrictDecoder(data).Decode(&dst.LineString)
	if err == nil {
		jsonLineString, _ := json.Marshal(dst.LineString)
		if string(jsonLineString) == "{}" || *dst.LineString.Type != "LineString" {
			// empty struct or wrong Type (discriminator)
			dst.LineString = nil
		} else {
			match++
		}
	} else {
		dst.LineString = nil
	}

	// try to unmarshal data into MultiLineString
	err = newStrictDecoder(data).Decode(&dst.MultiLineString)
	if err == nil {
		jsonMultiLineString, _ := json.Marshal(dst.MultiLineString)
		if string(jsonMultiLineString) == "{}" || *dst.MultiLineString.Type != "MultiLineString" {
			// empty struct or wrong Type (discriminator)
			dst.MultiLineString = nil
		} else {
			match++
		}
	} else {
		dst.MultiLineString = nil
	}

	// try to unmarshal data into MultiPoint
	err = newStrictDecoder(data).Decode(&dst.MultiPoint)
	if err == nil {
		jsonMultiPoint, _ := json.Marshal(dst.MultiPoint)
		if string(jsonMultiPoint) == "{}" || *dst.MultiPoint.Type != "MultiPoint" {
			// empty struct or wrong Type (discriminator)
			dst.MultiPoint = nil
		} else {
			match++
		}
	} else {
		dst.MultiPoint = nil
	}

	// try to unmarshal data into MultiPolygon
	err = newStrictDecoder(data).Decode(&dst.MultiPolygon)
	if err == nil {
		jsonMultiPolygon, _ := json.Marshal(dst.MultiPolygon)
		if string(jsonMultiPolygon) == "{}" { // empty struct
			dst.MultiPolygon = nil
		} else {
			match++
		}
	} else {
		dst.MultiPolygon = nil
	}

	// try to unmarshal data into Point
	err = newStrictDecoder(data).Decode(&dst.Point)
	if err == nil {
		jsonPoint, _ := json.Marshal(dst.Point)
		if string(jsonPoint) == "{}" { // empty struct
			dst.Point = nil
		} else {
			match++
		}
	} else {
		dst.Point = nil
	}

	// try to unmarshal data into Polygon
	err = newStrictDecoder(data).Decode(&dst.Polygon)
	if err == nil {
		jsonPolygon, _ := json.Marshal(dst.Polygon)
		if string(jsonPolygon) == "{}" || *dst.Polygon.Type != "Polygon" {
			// empty struct or wrong Type (discriminator)
			dst.Polygon = nil
		} else {
			match++
		}
	} else {
		dst.Polygon = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.LineString = nil
		dst.MultiLineString = nil
		dst.MultiPoint = nil
		dst.MultiPolygon = nil
		dst.Point = nil
		dst.Polygon = nil

		return fmt.Errorf("data matches more than one schema in oneOf(Geometry)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(Geometry)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Geometry) MarshalJSON() ([]byte, error) {
	if src.LineString != nil {
		return json.Marshal(&src.LineString)
	}

	if src.MultiLineString != nil {
		return json.Marshal(&src.MultiLineString)
	}

	if src.MultiPoint != nil {
		return json.Marshal(&src.MultiPoint)
	}

	if src.MultiPolygon != nil {
		return json.Marshal(&src.MultiPolygon)
	}

	if src.Point != nil {
		return json.Marshal(&src.Point)
	}

	if src.Polygon != nil {
		return json.Marshal(&src.Polygon)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *Geometry) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.LineString != nil {
		return obj.LineString
	}

	if obj.MultiLineString != nil {
		return obj.MultiLineString
	}

	if obj.MultiPoint != nil {
		return obj.MultiPoint
	}

	if obj.MultiPolygon != nil {
		return obj.MultiPolygon
	}

	if obj.Point != nil {
		return obj.Point
	}

	if obj.Polygon != nil {
		return obj.Polygon
	}

	// all schemas are nil
	return nil
}

type NullableGeometry struct {
	value *Geometry
	isSet bool
}

func (v NullableGeometry) Get() *Geometry {
	return v.value
}

func (v *NullableGeometry) Set(val *Geometry) {
	v.value = val
	v.isSet = true
}

func (v NullableGeometry) IsSet() bool {
	return v.isSet
}

func (v *NullableGeometry) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableGeometry(val *Geometry) *NullableGeometry {
	return &NullableGeometry{value: val, isSet: true}
}

func (v NullableGeometry) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableGeometry) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


